# ORM. Применение Hibernate в Spring

**ORM** (англ. Object-Relational Mapping, рус. объектно-реляционное отображение, или преобразование) — технология программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования, создавая «виртуальную объектную базу данных»

**Hibernate** — это популярный фреймворк для объектно-реляционного отображения (ORM), который позволяет Java-разработчикам работать с базами данных с использованием объектно-ориентированного подхода, минимизируя необходимость написания SQL-запросов. Hibernate автоматизирует процесс преобразования объектов Java в строки базы данных и наоборот, обеспечивая удобный и эффективный механизм для взаимодействия с реляционными базами данных.

## ORM

Концепция ORM (Object-Relational Mapping)

ORM (Object-Relational Mapping) — это технология, которая позволяет разработчикам работать с базами данных, используя объектно-ориентированные принципы программирования. В контексте ORM объектно-ориентированная модель данных (сущности, объекты) отображается на реляционную модель данных (таблицы, строки). Это позволяет программам работать с базой данных, используя объекты и их свойства, вместо того чтобы писать и исполнять SQL-запросы вручную.

### Объектно-реляционное расхождение (Impedance Mismatch)

| Особенность          | Объектно-ориентированное программирование (ООП) | Реляционные базы данных (РБД) | Решение в ORM-системах |
|----------------------|------------------------------------------------|------------------------------|-------------------------|
| **Структура данных** | Объекты с полями и методами                   | Таблицы с колонками         | ORM сопоставляет классы с таблицами (Entity Mapping) |
| **Связи между сущностями** | Ассоциации (композиция, агрегация, наследование) | Внешние ключи, JOIN-запросы | ORM поддерживает аннотации (`@OneToMany`, `@ManyToMany`), ленивую/жадную загрузку |
| **Идентификация**    | Объекты идентифицируются по ссылке (указателю) | Записи идентифицируются первичным ключом (ID) | ORM автоматически генерирует ID или использует стратегию (`GenerationType.AUTO`) |
| **Связанность**      | Поддержка сложных иерархий объектов           | Плоская структура, связи через внешние ключи | ORM управляет связями с каскадным сохранением (`CascadeType.ALL`) |
| **Изменяемость**     | Объекты могут изменяться в памяти             | Записи требуют явного обновления в БД | ORM автоматически отслеживает изменения объектов и применяет их в БД (`@Transactional`) |
| **Обход структуры**  | Объекты могут ссылаться друг на друга через указатели | Данные соединяются через SQL-запросы (JOIN) | ORM реализует ленивую (`Lazy`) и жадную (`Eager`) загрузку данных |
| **Типизация данных** | Поддержка сложных типов (коллекции, вложенные объекты) | Только примитивные типы (int, varchar, date) | ORM преобразует объекты в примитивные типы (например, `@Embeddable` в Hibernate) |
| **Полиморфизм**      | Есть встроенный механизм полиморфизма         | Отсутствует, требует специальных схем (Single Table Inheritance, Table per Class) | ORM поддерживает стратегии наследования (`@Inheritance(strategy = InheritanceType.JOINED)`) |
| **Производительность** | Операции выполняются в памяти, доступ мгновенный | Запросы требуют обращений к диску, возможны задержки | ORM кэширует данные (`@Cacheable`), использует `FetchType.LAZY` |
| **Транзакции**       | Объекты изменяются в памяти, без необходимости фиксации | Требуется явное управление транзакциями (commit, rollback) | ORM использует автоматическое управление транзакциями (`@Transactional`) |

ORM помогает решить проблему “объектно-реляционного расхождения” (Object-Relational Impedance Mismatch), которая возникает из-за различий в моделях данных между объектно-ориентированным программированием и реляционными базами данных. Основная цель ORM — упростить взаимодействие между объектами в коде и данными, хранящимися в базе данных.

### Основные принципы ORM

1. Объекты и таблицы: В ORM система объектов Java (или другого языка) отображается на таблицы базы данных. Каждый объект обычно соответствует одной строке таблицы.
2. Атрибуты объектов и столбцы: Свойства объектов отображаются на столбцы таблицы. Атрибуты объекта (например, поля класса) являются атрибутами, которые будут храниться в базе данных.
3. Связи между объектами и внешние ключи: Ассоциации между объектами (например, отношения “один к одному”, “один ко многим”, “многие ко многим”) отображаются на внешние ключи в базе данных.
4. SQL-запросы через объекты: Вместо написания SQL-запросов вручную, разработчик может работать с объектами, а ORM фреймворк сам генерирует SQL-запросы для выполнения операций с базой данных.

### Преимущества ORM

1. Абстракция SQL-запросов: ORM фреймворк автоматически генерирует SQL-запросы для стандартных операций, таких как создание, чтение, обновление и удаление данных (CRUD), избавляя разработчика от необходимости писать SQL вручную.
2. Упрощение работы с базой данных: ORM позволяет работать с данными как с объектами, что соответствует принципам объектно-ориентированного программирования. Это снижает сложность взаимодействия с базой данных и позволяет разработчику сосредоточиться на бизнес-логике.
3. Переносимость: Приложение, использующее ORM, становится менее зависимым от конкретной СУБД (системы управления базами данных). При изменении базы данных (например, переход с MySQL на PostgreSQL) требуется минимальные изменения в коде приложения.
4. Управление транзакциями: ORM-фреймворки часто включают в себя механизмы управления транзакциями, что помогает гарантировать атомарность операций с базой данных и упрощает работу с транзакциями.
5. Поддержка кэширования: Многие ORM системы включают в себя механизмы кэширования на уровне сессии или второго уровня, что позволяет улучшить производительность за счет сокращения количества запросов к базе данных.
6. Управление связями между сущностями: ORM упрощает управление связями между сущностями, такими как связи “один к одному”, “один ко многим” и “многие ко многим”.

### Проблемы и ограничения ORM

1. Производительность: В некоторых случаях использование ORM может привести к ухудшению производительности по сравнению с ручной оптимизацией SQL-запросов. Например, чрезмерное количество запросов, не оптимизированные запросы или ошибки в конфигурации могут вызвать избыточную нагрузку на базу данных.
2. Сложность в сложных запросах: ORM хорошо подходит для работы с базовыми CRUD-операциями, но в случае сложных запросов, которые требуют нескольких объединений таблиц или сложных условий, может возникнуть необходимость в ручной оптимизации запросов.
3. Миграции и версии базы данных: ORM не всегда может эффективно управлять миграциями схемы базы данных при изменении бизнес-логики, что требует дополнительных инструментов или библиотек.
4. Объектно-реляционное расхождение: Несмотря на то что ORM решает многие проблемы объектно-реляционного расхождения, иногда между объектно-ориентированными моделями и реляционными схемами все равно возникают трудности, такие как различия в типах данных, связи и особенности производительности.

### Как работает ORM: Пример

Предположим, у нас есть классы Persona и Character, которые мы хотим отобразить на соответствующие таблицы в базе данных.

1. Модели данных (сущности):

``` java
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;
import javax.persistence.ManyToOne;

@Entity
@Table(name = "personas")
public class Persona {

    @Id
    private Long id;
    private String name;
    private int level;

    @ManyToOne
    private Character character;

    // геттеры и сеттеры
}

@Entity
@Table(name = "characters")
public class Character {

    @Id
    private Long id;
    private String name;

    // геттеры и сеттеры
}

```

В этом примере мы определяем две сущности: Persona и Character. Связь между ними установлена с помощью аннотации @ManyToOne, которая означает, что одна персона может принадлежать одному персонажу.

2. Хранение данных:

Когда мы сохраняем объект Persona, ORM фреймворк автоматически генерирует SQL-запрос, чтобы вставить строку в таблицу personas. Также он автоматически создает ссылку на строку в таблице characters через внешний ключ.

``` java
Persona persona = new Persona();
persona.setName("John Doe");
persona.setLevel(50);
persona.setCharacter(character); // character — это объект класса Character

entityManager.persist(persona);  // Сохраняем объект в базе данных
```

В результате вызова метода persist(), ORM автоматически сгенерирует SQL-запросы, чтобы вставить данные в таблицы, и выполнит их.
3. Извлечение данных:
   
``` java
Persona retrievedPersona = entityManager.find(Persona.class, 1L); // Находим персону по ID
System.out.println(retrievedPersona.getName()); // Выводим имя персоны
``` 

ORM будет автоматически преобразовывать результаты SQL-запроса в объекты Java, избавляя разработчика от необходимости вручную извлекать данные из базы и преобразовывать их в объекты.

Популярные ORM-фреймворки

1. Hibernate — один из самых популярных фреймворков ORM для Java. Это мощный инструмент, который поддерживает широкие возможности для работы с базами данных и отлично интегрируется с Spring.
2. MyBatis — это фреймворк, который тоже позволяет работать с базой данных, но в отличие от традиционного ORM, он больше ориентирован на использование SQL-запросов и их маппинг на объекты, чем на полную абстракцию базы данных. Это не совсем ORM система, это Query Mapper (или Data Mapper) система.
3. EclipseLink — это еще один популярный фреймворк для работы с JPA, предлагающий мощные возможности для работы с базами данных.

## Спецификация JPA и ее реализация в библиотеке Hibernate

**Java Persistence API (JPA)** — это спецификация для работы с объектно-реляционными данными в Java-приложениях. Она определяет стандартизированные интерфейсы для маппинга объектов Java на реляционные базы данных, но не является конкретной реализацией.

**Hibernate** — это одна из самых популярных реализаций JPA. Он предоставляет мощный ORM (Object-Relational Mapping) механизм, позволяя разработчикам работать с базой данных через объектно-ориентированный подход.

| Концепция               | Описание |
|-------------------------|----------|
| **Entity**             | Класс, который представляет таблицу в БД. |
| **EntityManager**      | Основной интерфейс для работы с сущностями (CRUD-операции). |
| **Persistence Context** | Контекст управления объектами, аналогичный Unit of Work. |
| **JPQL (Java Persistence Query Language)** | Объектно-ориентированный язык запросов, аналог SQL. |
| **Transactions**       | Управление транзакциями (`commit`, `rollback`). |
| **Relationships**      | Определение связей между сущностями (`@OneToOne`, `@OneToMany`, `@ManyToMany`). |
| **Inheritance Mapping** | Поддержка стратегий наследования (`Single Table`, `Joined`, `Table per Class`). |

